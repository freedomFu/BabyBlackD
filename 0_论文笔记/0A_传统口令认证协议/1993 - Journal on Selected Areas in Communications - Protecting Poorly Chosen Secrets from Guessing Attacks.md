> **基本信息**
>
> 1993 - IEEE Journal on Selected Areas in Communications - Li Gong
>
> Protecting Poorly Chosen Secrets from Guessing Attacks 保护弱口令以防止猜测攻击
>
> **老师批注**：关于**离线字典攻击**的原始攻击EKE

### 总结归纳和应用

这篇文章结构严谨，介绍事情的思路非常值得学习和思考。

#### 研究背景

在安全系统中，用户**选择弱口令**是难以避免的，可能遭受猜测攻击，如何在使用弱口令（便利性）的情况下保证高安全性是一个热点问题

- 基本的思想是保证攻击者获取的数据是足够不可预测的，攻击者无法进行离线验证它的猜测是否正确，但接收者可以顺利接收这些信息

现实世界中，基于用户选择的弱口令的猜测攻击是存在的，包括存储口令的系统和基于口令加密通信网络，三个典型的攻击例子：

- UNIX口令系统，在`/etc/passwd`中存储着用户口令$p$的哈希值，一些运营商为口令添加随机选择的盐值$s$，通过单向哈希函数计算$g(p,s)$并将结果存储在文件中，令$h(p)=g(p,s)$，攻击者可以拿到盐值并猜测$p'$使$h(p')$与上述值匹配，若匹配可猜测$p'=p$。一个可能的解决办法是限制对于`/etc/passwd`文件的访问。
- SunOS安全网络文件系统（NFS），不在`/etc/passwd`中存储口令，采用公钥系统来增强安全性，引入`/etc/publickey`，存储用户名、公钥和私钥，其中私钥使用用户口令派生的密钥通过DES加密，用户登录时可以用口令解密私钥，可以通过公私钥对的关系来进行口令猜测攻击。一个方法是限制对于`/etc/publickey`的访问。
	- 对弱口令的猜测攻击可能会导致其他密钥的泄露，而两个系统相关联的时候也可能暴露在危险当中。一个用户可能在两个系统中有账号，如果它使用了相同的口令，加密的信息如果有关联，则可以猜测口令并观察解密信息是否有关联，这扩大了猜测攻击的影响范围，单个系统可能没事，但几个一起就完蛋了
- Kerberos鉴别系统
	- 服务器给用户请求的最初响应包含了可识别的信息如时间戳$t$和网络服务地址$S$，加密响应的密钥来源于用户选择的口令，则响应包为$\{t,S,...\}$，攻击者可以记录这个响应并进行猜测，$m'=\{\{t,S,...\}_p\}_{p'}^-$，可以得到信息$t'$和$S'$，可以通过判断时间和服务名是否处于一个合理的范围来验证猜测是否正确。

猜测攻击可以成功的原因除了口令来自较小的密钥空间之外（好的口令来自一个`large key space`），还有：

- 每一次猜测结果对应的数据都有**明显的特征**告知来告知攻击者猜测是否正确，比如上述的时间戳或服务名 （*可验证*）
- 猜测可以离线自动化进行，而且不会触发警报 （*不可检测*）

#### 研究内容

> 这里要注意，猜测攻击是否与离线挂钩呢？交互的建议就是针对离线来做的？这里再看时要注意一下。

防止猜测攻击可以让`guess`只有在与服务器交互的时候才能验证，可以记录猜测的次数，当超过阈值时可发出警告。

作者构造了`Needham-Schroeder`风格的鉴别协议，其中猜测攻击必须与鉴别服务器交互才能知道猜测是否正确。作者以此协议为基准，添加了实践考虑因素并提出了一些协议变体，比如减少交互次数、使用随机数代替时间戳、使用简单的认证协议以及没有第三方可信实体时的直接鉴别等。最后，作者也提出了一种检测协议是否存在猜测攻击漏洞的方法。

##### 概念引入（这里引入这个概念对于我理解这个文章有啥用呢？❗️）

###### Known Plaintext 已知明文

（已知明文攻击）如果一个密码分析师可以在拿到一部分密文的情况下预测出部分或所有明文，那么这个消息就包含`known plaintext`。任何可以预测的信息都可能构成`known plaintext`，比如这篇文章即使加密了，也可以知道这篇文章中包含`key`、`password`等

- 对称密码系统，攻击者可能拿到了$\{m,n\}_k$，并且已知$m$，它可以猜测$k'$并计算$\{\{m,n\}_k\}_{k'}^-$来看结果中是否包含$m$，如果包含则证明可能猜测是正确的，拿到了$p'$
- 如果是公钥系统，攻击者不能去猜测私钥，但是如果它知道$\{m,n\}_k$，$m$和$k$，这样它可以猜测$n'$，使它匹配$\{m,n\}_k$,如果匹配则证明猜测正确了，因为公钥算法解密不能有两种结果

已知明文攻击就是攻击者通过一部分它已经拿到的明密文对进行攻击，它可以知道密文的一部分信息解密后是什么。

###### Verifiable text

它可能是明文、密文或者是一系列计算之后的结果

攻击者在进行猜测攻击时，可能发现一些它已经知道或者有辨识度的内容，如果它能发现这样的内容，这个猜测正确的几率就非常大。

$P\{y|x\}$表示当$x$为真时，$y$为真的概率，$t$为门限，对于一个`s`，`v`满足以下条件则可认为是`verifiable text`

- 攻击者可以分辨出`v`
- 存在一个函数$f()$有$v =f(s)$，而且攻击者可以猜测$s'$计算$f(s')$
- $P\{s=s'|f(s)=f(s')\}>=t$

此时可以去思考，攻击者希望这样的攻击时可以以离线方式进行的，$t$是系统的容忍程度，如果$t=1$，攻击者是可以做离线猜测的，而如果$t=1/n$，其中`n`是所有可能是真的的口令的总数，这样猜测攻击就可能不成立， 如果$t$处于两者之间，攻击者仍有可能通过离线攻击来缩小范围。实际上，只有当$t=1/n$时，对于这种攻击，系统才算是完全安全的。

> 这里算不算是给下述的协议定义了一个安全目标？真正需要保证的是加密的消息不会有特别明显的特征

##### 保护技术

###### 普通两次握手

> $1. A→B:\{n\}_k$
>
> $2.B→A:\{f(n)\}_k$

n为随机数，使用k加密，它们是对称的关系，各自来说都是安全的，但是如果两者在一起使用，则可以通过猜测$k'$去解密查看结果是否有关联

###### 两个密钥的两次握手

> $1. A→B:\{n\}_{k1}$
>
> $2.B→A:\{f(n)\}_{k2}$

使用两个不同的k，只有同时猜测两个k才能猜测成功，这相当于同时搜索两个很大的key space，如果有一个是`well-chosen`，就非常难猜

但是k1可能是公开的，k2是用户选择的弱口令，它加密的信息已知，如果f(n)很容易求逆，比如$f(n)=n+1$，则攻击者可以对2攻击，得到$n'$，使用k1加密并比对，得到猜测结果

###### 使用随机数的两次握手

引入大的随机数，`confounder`，放入到公钥加密的`verifiable message`中，合法的接收者可能会无视这个信息，因为上述攻击者可以攻击2，而这里c扮演了一次一密的角色，攻击者必须得到`k1`私钥或者同时得到`k2`私钥和`c`才能构造1进而去验证猜测，这两者都不可行

> $1. A→B:\{c,n\}_{k1}$
>
> $2.B→A:\{f(n)\}_{k2}$

###### 使用`mask`的两次握手

另外，f(n)和n中可能包含一些可识别的信息，可以使用逐位模二加法运算⊕来避免通过这个特征来攻击

> $1. A→B:\{c_1,c_2,n\}_{k1}$
>
> $2.B→A:\{c_2⊕f(n)\}_{k2}$

B在收到$c_2$后需要用它对$f(n)$做掩码运算，而A一直$c_2$，可以计算$f(n)$，这样攻击者不能单独对2进行攻击了

⊕⊕⊕

##### 鉴别协议

应用上述保护技术，一些实用的鉴别协议可以抵抗猜测攻击。

以下的鉴别协议都是遵守让鉴别服务器产生会话密钥，为什么？

- 对于一个确定型状态机来说，生成高质量的随机数一般是困难或者是不可能（无随机种子）的
- 一些加密算法的密钥可能被密码分析，应该避免使用（客户端即使能生成随机数也无法识别这样的密钥）

以下协议没有直接发送口令，而是一个由口令产生的结果

如果有一个可信第三方服务器S的话，它可以帮助A和B来协商，进行双向鉴别

###### 双向鉴别协议

$1.A→S:\{A,B,na1,na2,ca,\{ta\}_{Ka}\}_{Ks}$

$2.S→B:A,B$

$3.B→S:\{B,A,nb1,nb2,cb,\{tb\}_{Kb}\}_{Ks}$

$4.S→A:\{na1,k⊕na2\}_{Ka}$

$5.S→B:\{nb1,k⊕nb2\}_{Kb}$

$6.A→B:\{ra\}_k$

$7.B→A:\{f1(ra),rb\}_k$

$8.A→B:\{f2(rb)\}_k$

其中，$na1,na2,ca,ra,nb1,nb2,cb,rb$都是来源实体产生的随机数，$Ks$是服务器的公钥，$Ka$和$Kb$分别是A与B和S共享的密钥，如果它们是人，则可能是从用户口令中派生得到的，$k$是A和B的会话密钥， $t_a$和$t_b$是一个可以识别出来的信息，但是不会重复，比如时间戳，它的精读比允许的客户端到服务器的时间偏差要大

1和3类似，解释1。A生成三个随机数$na1,na2,ca$并产生实时性的信息（保证新鲜度），意思是它是A，想和B通信，$Ks$只用于加密初始的请求

服务器可以用私钥解密1和3 的请求，并且通过验证新鲜度信息来验证它们的身份，如果时钟不匹配，不符合最大偏差，则服务器会记录这个错误，否则就成功，返回4和5。另外服务器可能选择一个随机的信息作为鉴别失败信息给攻击者。

4中包含$na1$，表明服务器解密了1的消息，服务器响应前已经对消息做了验证，所以一个假的1不会从4中得到有用的消息。

另外4中包含$na2$，因为：

- 没有na2，攻击者可以猜测Ka，并进而通过k来验证猜测。另外内部也有可能被攻击，比如B已知k，可以猜测Ka，并解密4来验证猜测。（**这两个是递进还是并列关系？**）

另外，ca和cb也是可以防止B内部攻击，如果1没有ca，$A→S:\{A,B,na1,na2,\{ta\}_{Ka}\}_{Ks}$，B已知k，可以猜测Ka,得到na1,na2,并重构1，进而可以去猜测Ka

6和7，是挑战与应答，k可以被认为是`well-chosen`的，ra和rb可以被替换为时间戳

本协议使用了时间戳，如果攻击者不知道时间，它能够验证猜测成功与否的概率就更小了，另外如果精度高于攻击者已知的，则可能精度高的位置也可以作为`confounder`，一个随机的时间可以让攻击更加困难。

另外1、3中的时间戳可能有其他的影响，如果时间戳被换成了不能反映新鲜度的消息，S不能知道1是否是一个新鲜的消息，攻击者可能可以用之前记录的1得到一个新的响应。

- 攻击者可能能得到两个$\{na1,k⊕na2\}_{Ka},\{na1,k'⊕na2\}_{Ka}$，可以通过猜测Ka来看na1是否匹配。所以随机的信息不能复用，S也应该检测重放，应该存储消息到一个时钟间隔大于最大时钟偏差时再丢弃，而使用随机数可能比时间戳要好一些。

###### 一个紧凑的协议 类似于 Otway87

$1.A→B:\{A,B,na1,na2,ca,\{ta\}_{Ka}\}_{Ks},ra$

$2.B→S:\{A,B,na1,na2,ca,\{ta\}_{Ka}\}_{Ks},\{B,A,nb1,nb2,cb,\{tb\}_{Kb}\}_{Ks}$

$3.S→B:\{na1,k⊕na2\}_{Ka},\{nb1,k⊕nb2\}_{Kb}$

$4.B→A:\{na1,k⊕na2\}_{Ka},\{f1(ra),rb\}_k$

$5.A→B:\{f2(rb)\}_k$

###### 使用随机数

服务器分发$ns$，检测重放攻击

$1.A→S:A,B$

$2.S→A:A,B,ns$

$3.A→B:\{A,B,na1,na2,ca,\{ns\}_{Ka}\}_{Ks},ns,ra$

$4.B→S:\{A,B,na1,na2,ca,\{ns\}_{Ka}\}_{Ks},\{B,A,nb1,nb2,cb,\{ns\}_{Kb}\}_{Ks}$

$5.S→B:\{na1,k⊕na2\}_{Ka},\{nb1,k⊕nb2\}_{Kb}$

$6.B→A:\{na1,k⊕na2\}_{Ka},\{f1(ra),rb\}_k$

$7.A→B:\{f2(rb)\}_k$

###### 认证协议

一些特定的交互不需要`session key`，也可能不需要双向鉴别，比如ATM需要被认证但是后续的交易可以不在加密情况下进行

$1. A→S:A$

$2.S→A:ns$

$3.A→S:\{A,ca,\{ns\}_{Ka}\}_{Ks}$

该协议对于智能卡等很右移，它只需要存储公共信息比如$Ks$，一个正确的PIN可以让智能卡正常使用，而攻击者盗窃的card则没有用，所以智能卡的制作成本很低，不需要保证防止篡改，而且也不需要与用户管理所以管理成本也降低了

###### 使用秘密公钥 Using Secret Public Keys

一些用户可能无法记住$Ks$，上述的协议转换之后也可以用于这个协议，比如让S给A和B分别派发一个公钥

$1.A→S:A,B$

$2.S→A:A,B,ns,\{Ksa\}_{Ka},\{Ksb\}_{Kb}$

$3.A→B:\{A,B,na1,na2,ca,\{ns\}_{Ka}\}_{Ksa},ns,ra,\{Ksb\}_{Kb}$

$4.B→S:\{A,B,na1,na2,ca,\{ns\}_{Ka}\}_{Ksa},\{B,A,nb1,nb2,cb,\{ns\}_{Kb}\}_{Ksb}$

$5.S→B:\{na1,k⊕na2\}_{Ka},\{nb1,k⊕nb2\}_{Kb}$

$6.B→A:\{na1,k⊕na2\}_{Ka},\{f1(ra),rb\}_k$

$7.A→B:\{f2(rb)\}_k$

该协议不需要S公钥预先分发，但是对于公钥系统的选择也添加了限制，$Ksa$必须在A和S之间保持秘密，不能揭露，如果$Ksa$被公示，消息2就可以被发动猜测攻击（$Ka$）

另外$Ksa$也不应该包含任何攻击者已知的额外信息，它应该足够随机

加密包含`confounders`的随机消息一定不能暴露加密密钥，在上述协议中公钥不一定是公开的

###### 直接认证

一些场景中，可信实体$S$可能不存在，A和B可能共享了一个弱的密钥$Kab$，但是它们仍然希望以安全方式建立会话，并得到一个足够强的会话密钥。$Kab1$是公钥，$k$是会话密钥，它们都是A选择的

$1.A→B:ra,\{Kab1\}_{Kab}$

$2.B→A:\{B,A,nb1,nb2,cb,\{ra\}_{Ka}\}_{Kab1}$

$3.A→B:\{nb1,k⊕nb2\}_{Kab}$

$4.B→A:\{f1(ra),rb\}_k$

$5.A→B:\{f2(rb)\}_k$

A可能为每个会话生成一个新的公钥$Kab1$。如果需要A和B共同厕，则可以生成k1和k2，并通过哈希函数来计算$h(k1,k2)$

##### 检测弱点 Detecting Vulnerability

如何检测一个协议的弱点？文中的方法是：

- 收集所有可能被攻击者获得的信息（信息来源是一个或多个协议的多次执行），并且假设攻击的初始目标是潜在的`poorly chosen secrets`，并在这些信息中查找看是否包含可以去验证一个猜测的信息。

- $M$集合，包含所有的消息、构成组件和构成消息的密钥，比如消息$\{A,t\}_k$，$M$中包含$A,t,k$以及$\{A,t\}_k$
- $R$集合，规则集合，通过组合$M$中的元素可以得到什么，比如从$A,t,k$可以组合出$\{A,t\}_k$，但是$A,t,\{A,t\}_k$可能无法推断出$k$，即这里可以认为每一个规则都对应着一个计算复杂度，如果复杂度过高则可以认为攻击者无法实施攻击，可以舍弃或者标记为复杂性无限，未来可能可以解决。 其中一个元素可以表示为$(A,t,k→\{A,t\}_k)$
	- $R$需要足够相近，可以通过对称的方式构造，因为一开始这个集合是空的
		- $x=f(x_0,x_1,...,x_{n-1})$，可以添加规则$(x_0,x_1,...,x_{n-1}→x)$，如果$f()$可逆，则可以添加$(x_0,x_1,...,x_{i-1},x,x_{i+1},...,x_{n-1}→x_i)$
		- 对于对称密码系统，$y=\{x\}_k$，加密为$(x,k→y)$，但$(x,y→k)$代表可能有已知明文攻击
- $W$集合包含了攻击者希望知道的消息，可能包含窃听者可能记录的所有消息，除了攻击者可能知道的信息之外，对于$R$中的每一个规则，$(x_0,x_1,...,x_{n-1}→x)$，如果$W$包含所有的$x_i$，则$x$也应当添加到$W$中，即它应该在规则$R$下达到终止
- $G$集合包含了所有攻击者可能选择去猜测的`secret`
	- $W$和$G$对于不同的攻击者可能不同
- $V$集合是$M$之内的`verifiable text`，在满足以下条件下，x是一个`verifiable text`，如果有一个rule$(x_0,x_1,...,x_{n-1}→x)$，$x_i∈W∪G∪V$，且不是每一个$x_i∈W$，比如$A∈W,t∈W,k∈G$，$\{A,t\}_k$就是`verifiable`，也就是一个$G$可以对应一个x，如果攻击者拿到了两个$G$中的元素$g,g'$，并且拿到了两个x即$t,t'$，如果$x∈W∩V$，且$P\{g=g'|t=t'\}$足够大，可以通过计算x来猜测`secret`。
	- 对于`verifiable`文本的查找可以归类到图论中的路径搜索问题，$M$中的每个消息作为有向图中的结点，假设$W∪G$中的元素对应的结点是可以到达的，对于$R$中的推导关系，如果$x_i$可达，则$x$可达，想去查询$W∪G$中是否存在一个$W$结点它所在的路径有$G$结点，可以到达一个$W$的结点，路径最末端的结点就是一个`verifiable text`

这样的发现就可能导致一种攻击，算法可以找到所有的路径，算法的复杂度决定了路径长短，路径较短则可以以最小的代价实现攻击。

###### 对EKE的介绍

$1.A→B:A,\{k\}_p$

$2.B→A:\{\{r\}_k\}_p$

$3.A→B:\{ra\}_r$

$4.B→A:\{ra,rb\}_r$

$5.A→B:\{rb\}_r$

文章也提出了一部分EKE提出协议的问题，但是是否合理有待商榷

### 研究内容与解决问题

#### 研究内容

文章提出了一种同时保证用户方便及高安全性的弱口令解决方法，**基本思想**为：保证攻击者能获取到的数据是不可预测的，这样可以防止攻击者**能够离线验证猜测**是否正确。

- 这里的重点是：获得的数据是不可预测的，这样攻击者将无法迅速判断猜测的口令是不是正确的（但这些信息是足以让接收者接受的）

作者测试了猜测攻击的通用形式，举了免疫这种攻击的密码协议的例子并与之对称地提出了检测协议是否有这种漏洞的方法

#### 提出问题

- 实践中，弱口令如何能保证安全呢？
- 检测猜测攻击的方法是什么？
- 在设计中是如何使用公钥密码体制的？它为什么重要？

### 研究方法（创新点）

以Needham-Schroeder风格的鉴别协议为基础，提出了几种保护技术及能对抗口令猜测攻击的协议，并且提出了一种检测协议是否有这种猜测攻击漏洞的方法。

### 文章脉络

#### 小标题结构

- 1 Introduction
- 2 Guessing Attacks
	- 2.1 The UNIX Password System
	- 2.2 SunOS Secure NFS
	- 2.3 The Kerberos Authentication System
- 3 Known Plaintext and Verifiable Text
- 4 Protection Techniques
- 5 Authentication Protocols
	- 5.1 A Mutual Authentication Protocol
	- 5.2 Reducing the Number of Messages
	- 5.3 Using Nonces
	- 5.4 Identification
	- 5.5 Using Secret Public Keys
	- 5.6 Direct Authentication
- 6 Detecting Vulnerability
- 7 Related Work
- 8 Summary and Suggestions for Further Work

#### 1 Introduction

##### 研究背景

`poorly choosen password`容易遭受到离线猜测攻击：复制信息并离线实验（比如保留口令的哈希值或使用口令作为加密密钥的加密信息等）。

- 密码猜测攻击通常与存储口令的系统有关，而对于网络中信息受到这种攻击的可能性则经常被忽视。
- 用户选择的弱口令则使这种攻击更容易成功 `poorly chosen`，攻击者猜测成功的概率相对较高
- 从`large key space`随机选取的加密密钥则是`well chosen`，攻击者猜测成功的概率相对较低

###### 实际案例

Kerberos鉴别系统容易受到猜测攻击，它的密钥分发服务器使用用户的口令加密了一个初始的响应包，攻击者可以记录这个包并通过离线猜测口令。攻击者可以轻而易举地验证猜测是否正确，因为这个包的解密结果会产生一个有辨识度的数据：一天的时间和网络服务的名称

`guessing attacks`在可以自动生成猜测并可以被验证时是最有效的：因为这样攻击者可以验证猜测是否正确，而这样的猜测不会产生警报

在Kerberos中，这样的猜测可以离线进行，所以这样的攻击在计算上是可行的，而且错误的猜测尝试也不会被检测到

###### 对策

鼓励用户选择费解且难以猜测的口令，但是这是不好记的，不方便，长口令是类似的。（比如ATM的PIN码只有4~6位，再长的PIN码可能就需要写下来才能记住）

作者之前文章提到了一种在用户使用弱口令的情况下改善安全的方法，`verifiable plaintext`，可证实的明文，它是一种这样的消息：已知明文组成了一个子集。

> We described what we called verifiable plaintext, which is a type of message of which known plaintext forms a subset. Other writers have not, to our knowledge, explored the distinction between these two kinds of plaintexts.

###### 本文工作

在上述的想法中进一步扩展，提出了`verifiable text`的普遍概念，并提供了让猜测攻击失败的技术

- 目标是让攻击者得到的数据足够不可预测，这样可以防止攻击者使用离线验证来看猜测是否正确。
	- 信息包含足够的冗余让目的接收者接受，但对于攻击者做离线字典攻击是不够的
		- 猜测验证的唯一方法就是与系统做交互，比如ATM记会记录猜测，当到达一定次数后会发出警告
- 作者构造了`Needham-Schroeder`风格的鉴别协议，**即所有猜测攻击都必须与鉴别服务器交互也因此可以被服务器检测。**
	- 作者给出了之前的协议样例和几种变形，考虑了实际应用因素，比如消息流量的最小值，使用随机数代替时间戳，使用简单的认证如单向函数而不是密钥分发，在没有可信第三方作为鉴别服务器的时候直接鉴别
- 提出了一种检测协议是否可能遭受到猜测攻击的方法

以上的研究内容可以用于很多用户可能选择弱口令的场景

#### 2 Guessing Attacks

不考虑一些专业的攻击，如切片攻击（密文的重排或处理可能对明文产生可预见的结果）。这里假设，密文的每个bit都取决于明文的所有bit

${m}_k$代表k加密m，而${m}_k^-$代表解密

这个部分对于猜测攻击的可能的实际攻击场景进行了描述，包括

- UNIX口令系统
	- 存储对口令和盐值的哈希，以及盐值在`/etc/passwd`中，构造$h(p) = g(p, s)$对$p$进行猜测攻击
	- 通过限制对`/etc/passwd`的访问避免
- SunOS Secure NFS
	- `/etc/publickey`存储着口令加密的私钥，这可能被字典攻击
	- 通过限制访问`/etc/publickey`文件来防止
	- 另外一个用户在不同系统中的口令加密内容如果有关联是可能导致一连串的危害的
- Kerberos鉴别系统
	- 服务器给用户请求的初始响应一般会带有时间戳信息或者服务器名称，$\{t,S,...\}_p$，这可能被猜测攻击$m'$被限制在一个合理的范围内并进行判断

#### 3 Known Plaintext and Verifiable

#### 4 Protection Techniques

> - These structural properties generally increase the vulnerability to guessing attacks. When considering the pair as a single message with sufficient redundancy, redundancy is diiicult to access objectively. A message that can be recognized could appear to contain unrecognizable random to another.

#### 5 Authentication Protocols

> - The protection techniques could be applied to develop practical protocols, such as  authentication protocols, that are resistant to guessing attacks.
> - If the owner of a key is a person rather than a computer, the key would be derived algorithmically from the users’s password.