> 1998 - NDSS - Secure Remote Password (SRP) Authentication 安全远程口令鉴别
>
> **摘要：**本文提出了一种新的口令鉴别和密钥交换的协议，可以在不可信的网络中做用户鉴别和密钥交换，可以抵抗字典攻击，也可以提供完美前向安全性。口令在数据库中存储的方式与口令本身是不明文对等的（plaintext-equivalent），即使可以破解口令数据库也无法直接用于攻击。新的协议结合零知识证明、非对称密钥交换并提供了更高的性能。

## 前言

本文讲述的是一种特殊的分类，direct password authentication，它不依赖一个永远存储在客户端中的信息，只需要口令，而且没有可信的第三方实体可以用。作者提出，直接鉴别协议的一个应用常见，即用于远程口令保护的计算机访问，提出如果口令可以不使用明文传输的话，就会更加安全（透明的方式），另外一个方面是希望新提出的协议不会引入新的性能开销。

在文章中，作者提到的client和server分别代表用户user和服务器host的实体，password和verifier分别代表私钥和公钥，password比通常定义的私钥要低熵，verifier是与公钥有类似的数学属性，它可以从password中计算出来，但是从verifier中计算password是比较困难的，verifier是一个服务器存储的秘密信息，只需要verifier来进行验证的机制称为verifier-based机制。

基于零知识，可以让协议不会泄露任何关于口令的信息，而且不存储口令明文对等的信息可以保证内部攻击无法直接获取口令。

## 新框架

### AKE

#### 不需要加密带来好处

- 通过省略协商公共加密算法的过程来简化协议
- 避免了加密过程的脆弱性带来的安全性影响
- 避免了加密算法法律约束或使用权带来的影响

#### 协议细节

AKE采用的是 **swapped-secret** 的方法，一方计算secret，然后执行单向函数来生成 verifier并提供给另外一个实体，而且在有服务器的情况下，只需要一方实体生成secret并计算verifier即可。

存在一个等式1：

$(∀w,x,y,z)---S(R(P(w),P(x)),Q(y,z))=S(R(P(y),P(z)),Q(w,x))$



### Secure Remote Password 







## 1 引言

口令鉴别协议解决了一个共同的问题：一个实体向另一个实体证明它知道一个口令$P$，但是协议的形式复杂性不一，而且大部分协议都提供了一定程度的保护机制。

当前对用户鉴别的方式有以下三种：

- sth user is
- sth user has 
- sth user know ✨  即有口令和PIN

在一个口令鉴别协议当中，口令是一个可以记忆的数字，是客户端软件可以得到的。另外，一般假设客户端和服务器之间的网络是容易受到敌手窃听和篡改攻击的，也没有一个公共第三方实体，只有客户端和服务器两个实体可以参与到这个鉴别协议当中，这样的协议在实际应用中是非常普遍的，因为除了一个需要记住的口令，其他信息都不需要记住，相比于生物或token鉴别的方式，这不仅易用而且廉价。

一个很普遍的应用是处理远程、口令保护的计算机访问。当前在使用的协议更多采用明文口令来鉴别，大多数协议都在建议采用更安全的方式来实现，而且不会引入用户可见的性能开销。

一个好的口令系统可以引入一个强大的因素来作为鉴别系统的一个因素，这包含一种多因素的系统：口令 + 手持设备或生物因素。

## 2 相关研究

### 相关术语

- client → user  指代人，比如计算机用户，只能记住相对短的口令，这里认为用户不能记住一些比较长的口令
- server → host 代表主机，也就是用户想访问的资源所在的服务器
- password → 私钥，但是它只有有限的熵值，受限于用户的记忆
- verifier → 具有公钥相似的数学属性，可以从password中计算出来，但是从verifier中得到password是不可行的。它是服务器负责保密的
- 需要服务器存储用户口令的副本的鉴别机制称为 `plaintext-equivalent`机制
- 只需要存储`verifier`的称为`verifier-based`机制，它具有一个优势是：
	- `plaintext-equivalent`机制在服务器被破坏之后所有的口令都会被获得
	- 而`verifier`可以和上述明文口令一样存储，但是服务器被破坏不会带来那么大的损害

任何合理的安全鉴别协议都不会泄露有关口令的任何信息，而基于`zero-knowledge`的协议甚至不会把口令泄露给一个合法的主机域

### 现存鉴别技术

最传统的方式是发送用户名和口令然后与服务器中存储的内容进行对比，可能遭到窃听，后续引入了挑战响应机制，可以避免窃听带来的重放攻击，但是仍然可以通过字典攻击来猜测，而且挑战响应协议也是明文对等的，所以如果能捕获到这个口令文件，就可以发动攻击。

为了改善这些鉴别机制，协议设计者通常使用三种方法之一来做：

- 使用类似smartcard的只能设备来增加key的长度
	- 不再基于 sth you know，丢失了只使用口令的便利性
- 通过物理环境来构造一个不容易被攻破的协议通道（扩频技术，量子密码）
	- 只适用于有限的应用
- 忽略问题并希望没人会注意到
	- 这可能会导致口令鉴别不再可信

### 更好的解决方法

92年的EKE，通过对称和公钥密码学的方法结合的方法来做，通过给被动窃听攻击者不充分的信息来抵抗字典攻击，EKE也做了密钥交换，这样两个实体可以在鉴别之后加密彼此的传输。

伴随着EKE的产生，后续出现了很多基于EKE的方案，例如DH-EKE和SPEKE增加了前向安全性，即攻击者获取一个口令不会帮助它获取后面的会话密钥，一个被盗窃的会话密钥不会帮助攻击者使用穷举攻击来获取口令。

EKE协议家族最大的问题就是它仍然遭受`plaintext-equivalence`，需要客户端和服务器都能访问相同的口令（即共享），后续提出了一种`Augmented EKE (A-EKE)`，它实现了`verifier-based`的EKE，但是没有了前向安全性。

而避免`plaintext-quivalence`问题已经成为安全协议设计的一个重要问题。另外，性能差也是好的协议应用的障碍，

## 3 A new framework 一个新的框架

定义一个基于`verifier`的协议比定义一个共享密钥的协议是更困难的，因为verifier和password是不对等，但是从password是可以推断出verifier的，但是受限于公钥密码学，只有比较少的方法可以进行必要的数学操作来构建基于verifier的安全协议，所以这种协议在实践中比较少见。

本文在这里提出了一种新的形式，*Asymmetric Key Exchange → AKE*，也是`verifier-based`协议。

### AKE

AKE和EKE的主要功能都是在客户端和服务器两个实体之间交换密钥，但是AKE没有加密任何协议流，而是使用预先定义好的数学关系结合交换的临时值来建立口令参数，而避免加密有如下的好处 *什么是避免加密呢？有什么特征吗？*

- 通过避免协商**公共加密算法**简化了协议，可以使协议依赖于一个特定的加密算法。
- 加密过程的缺点都可能导致整个鉴别协议的缺陷，而没有加密则可以清除这些缺陷。
- 不使用加密算法则不会被法律等因素影响。

另外，EKE通常还需要预先共享一个`secret`作为鉴别基础，即通信双方需要保留这个secret来互相鉴别，而拥有这个secert就可以伪装成另外一个实体，secret仍然是可能被盗窃的，所以两个实体都应该安全交换初始的secret并保护它。

而AKE是 *swapped-secret*，双方分别生成 *secret*并使用单向函数生成一个verifier并交给对方，这样即使敌手通过字典攻击获取了verifier，它也不能伪装成用户。在一种特殊情况下，只需要一方实体生成secret即可。

![image](https://user-images.githubusercontent.com/40269368/156870294-98023296-8457-422a-8697-af6d690e3aa4.png)

### SRP 一个AKE的构造形式





