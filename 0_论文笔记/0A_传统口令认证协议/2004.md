> 2004 - ASIACRYPT - Muxiang Zhang
>
> New Approaches to Password Authenticated Key Exchange based on RSA

---

老师好，我是付彦铎。

我认为这篇文章的主要问题包括：

在内容上：

​	本文设计的PEKEP协议和CEKEP协议都利用了数论技术来使协议不会遭受到e次剩余攻击。PEKEP中，Bob实体需要对信息进行$m+1$次加密，这让Bob的运算负担过大，在一些资源受限的场合中，可能是不适用的；在CEKEP中，作者在协议中增加了两个Flow，使整体协议达到了6个Flow，并不适用。另外，作者在背景中提到，SNAPI的问题包括素数测试和公钥加密两个部分，本文实际上只解决了素数测试运算大的问题，而另外一点并没有解决。

在格式上，一方面，作者在摘要和引言中先提到了对于协议的形式化安全性证明，后面才提到更高运算效率的CEKEP，而在正文中，这两点颠倒了；另一方面，在数学论证中有一些数学验证的说明并不完整。

老师好，我是付彦铎。

我认为这篇文章（2004 New Approaches to Password Authenticated Key Exchange based on RSA）的主要问题包括：

在内容上：

​         本文设计的PEKEP和CEKEP都利用了数论技术来保证协议不会遭受到e次剩余攻击，尽管能够抵抗e次剩余攻击，但是：

​        在PEKEP中，实体Bob需要进行m+1次加密操作，Bob的运算负担比较大，在一些资源受限的场合中，该协议可能是不适用的；另外，作者在背景中提到，SNAPI协议的性能问题包括素数测试和公钥加密两个部分，PEKEP实际上只解决了素数测试运算负担大的问题，而另外一点没有解决。

​        在CEKEP中，作者为了提高运算效率，在协议中增加了两个Flow，使整体协议达到了6个Flow才可以完成会话密钥的交换，交互的轮数同样会影响协议的性能。

在格式上：

​        作者在相关证明的部分，对于一些结论的说明不够完整，可能会产生歧义，另外也存在一些笔误。

​        作者在摘要和引言中均先提到了对于协议的形式化安全性证明，后面才提到具有更高运算效率的CEKEP，而在正文部分，这两点的顺序刚好颠倒过来。



老师，我还有一点问题：在阅读论文时，论文的问题会包括方案设计上的问题（如方案设计的假设性过强、方案没有完成初期设定的全部目标等）和逻辑上的问题（文章写作逻辑、实验设计思路的逻辑）等。从论文的背景和Motivation出发来看作者最终的结论以及在论证过程中的逻辑性是否是我在阅读或做笔记时最应该关注的呢？



谢谢老师！



付彦铎

---

**总结：**在基于RSA的PAKE协议安全性普遍较弱，安全的SNAPI协议由于要求$e>n$而实用性较差的背景下，作者提出了PEKEP，该协议允许$e$为小素数，而且可以抵抗$e$次剩余攻击。作者基于RSA假设和ROM模型对协议做出了形式化安全性分析，并进一步提出了具有更高计算效率的CEKEP。这两种协议无需共享公共参数，只需要共享口令即可。

---

**安全模型：**

- 定义实体$A,B∈I$，共享口令$p$，在协议$∏$中进行双向鉴别并生成会话密钥。$∏_A^i$表示实体$A$的第$i$个协议实例（也称为一个oracle），每个已接受的实例持有会话密钥$sk$，会话标识$sid$和伙伴标识$pid$。

- 敌手可以拦截、重组消息，也可以创建实例与其他实体的实例交互，也可以字典攻击，也可以从已接受的实体实例中获取会话密钥。敌手可以发送`oracle query`，类型包括：
	- $Send(A,i,M)$ : 代表中间人攻击，敌手向$∏_A^i$发送$M$，并接受响应，得到实例是否接受以及相对应的$sid$和$pid$
	- $Execute(A,i,B,j)$ : 代表窃听攻击，可以得到$A,B$交互过程中所有的交互信息，但无法获得关于会话密钥和口令的信息。
	- $Reveal(A,i)$ : $∏_A^i$的会话密钥$sk_A^i$发送给敌手
	- $Test(A,i)$ : 不是实际的攻击能力，而是度量会话密钥的语义安全性，会随机生成一个比特位，若$b=1$则返回给敌手真实的会话密钥，$b=0$返回随机会话密钥。该查询只能做一次
	- $Oracle(M)$ : 允许敌手访问函数$h$，即可以访问哈希函数并得到相应的值
- 协议实例的新鲜度
	- 实例已经被接受
	- $Reveal$查询没有发送给这个实例或它的伙伴
- 敌手的攻击目标
	- $Succ$代表$Ã$向一个新鲜的实例做$Test$查询，输出$b'$，而且$b'=b$的事件，敌手$Ã$的优势为$Adv_Ã^{ake}=2Pr(Succ)-1$
	- 如果不做限制，它就可以一直尝试，观察另一个协议的反应来验证猜测，也可以离线进行验证
- 对于一个安全协议，希望敌手一次只能测试一个口令，以$Send$作为在线猜测的次数，而且对于每个实例只记录一次$Send$，所以**一个安全的协议**，是对于多项式时间的敌手$Ã$对不同的实例至多做$Q_{send}$次$Send$查询，而且满足以下两个条件
	- 每个oracle call $Execute(A,i,B,j)$都会产生一对实例$∏_A^i$和$∏_B^j$，即这个查询会对已经接受的实例查询，它们一定有相同的会话密钥并互为伙伴
	- $Adv_Ã^{ake}≤Q_{send}/|D|+ε$，其中$|D|$为口令空间，这个表示敌手的攻击能力只与它能在线交互的次数相关。

---

**PEKEP** 基于RSA的PAKE协议，允许使用大的$e$和小的$e$，$A,B∈I，口令ω∈D，A生成n,e,d，n为大正数，以两个相同size的素数产生，e为正数与φ(n)互素，ed≡1(mod φ(n))$，加解密有$E(x)=x^e(mod(n)),D(x)=x^d(mod(n)),E^m(x)=x^{e^m}(mod(n)),D^m(x)=x^{d^m}(mod(n))$

有哈希函数 $H_1,H_2,H_3:\{0,1\}^*→\{0,1\}^k,H:\{0,1\}^*→Z_n,k为安全参数，如160$，哈希函数产生的数尽可能随机均匀  定义(验证e为奇素数，n为奇数为条件$C_1$)

*协议流程*

1. $A$发送公钥$(n,e)$和随机数$r_A∈_R\{0,1\}^k$给$B$
2. $B$验证条件$C_1$，不成立则拒绝；否则计算$m=└log_en┘$计算$a∈_R Z_n^*,r_B∈\{0,1\}^k$，计算$α=H(ω,r_A,r_B,A,B,n,e)$。检查$gcd(α,n)=1$，不成立，则$λ∈_R Z_n^*$,否则$λ=α$。计算$z=E^m(λE(a))$，发送$z,r_B$给A
3. A计算$α$，并判断$gcd(α,n)=1$，若不成立，则$b∈_R Z_n$，如果$gcd(α,n)=1$，则$z$是$n$的$e^m$次剩余，$b=D(α^{-1}D^m(z))$    $μ=H_1(b,r_A,r_B,A,B,n,e)$  发送$μ$给B
4. B计算$μ=H_1(a,r_A,r_B,A,B,n,e)$是否成立，如果不成立就拒绝，否则计算$η=H_2(a,r_A,r_B,A,B,n,e)$，$sk=H_3(a,r_A,r_B,A,B,n,e)$  发送$η$给A
5. A计算 $η=H_2(b,r_A,r_B,A,B,n,e)$看是否成立，不成立就拒绝，计算$sk=H_3(a,r_A,r_B,A,B,n,e)$，即完成相互认证并生成了会话密钥

> 上述协议流程，当$gcd(α,n)=1$不成立时会拒绝，但是为了不泄露信息，PEKEP会使用随机数进行后续流程（当n=pq，如果这两个值足够大且size相近时，这种情况几乎不存在，可以建立会话密钥）

但是上述流程中，B没有检查$e$与$φ(n)$是否互素，可能导致$e$次剩余攻击，敌手可以进行逐步猜测并从口令空间中一次排除多个口令：

- 从$D$中选择口令$π$,
- 计算$α=H(π,r_E,r_B,A,B,n,e)$
- 如果$gcd(α,n)=1$，可以验证$(αx^e)^{e^m}≡z(mod(n))$在$Z_n^*$上有解，如果有，则无法排除不符合的口令，如果无解则可以排除这个口令，如果一次可以排除一个以上口令，则敌手是可能成功的。

*定理1证明了PEKEP是可以防止e次剩余攻击的*，在$n>1,n=p_1^{a_1}p_2^{a_2}...p_r^{a_r},m为非负整数,e为奇素数，且e^{m+1}不整除φ(p_i^{a^i})$，如果$z是n的e^m次剩余，则对于任意λ∈Z_n^*$，等式$(λx^e)^{e^m}≡z(mod(n))$在$Z_n^*$有解

$n_i=p_i^{a_i}$只需要证明$(λx^e)^{e^m}≡z(mod(n))$







