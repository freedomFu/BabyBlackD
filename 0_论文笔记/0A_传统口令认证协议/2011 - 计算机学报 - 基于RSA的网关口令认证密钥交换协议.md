> **基本信息**
>
> 2011 - 计算机学报 - 魏福山 马传贵 - 基于RSA的网关口令认证密钥交换协议
>
> **关键词**：RSA；口令认证；网关；随机预言模型；e次剩余攻击
>
> **摘要**：网关口令认证密钥交换协议是一个三方协议，**用户和网关**可以在服务器协助下建立一个安全会话密钥，文章根据PEKEP协议，提出基于RSA体制的可证明安全的网关口令认证密钥交换协议，在随机语言模型下，基于RSA假设证明了协议的安全性，可以抵抗e次剩余攻击和不可检测在线字典攻击。
>
> **结论：**文章研究如何利用RSA体制设计高效的GPAKE协议，利用PEKEP协议设计了基于RSA的GPAKE协议，可以抵抗e次剩余攻击，且基于RSA假设在随机预言模型下证明了协议的安全性，而且协议可以抵抗不可检测在线字典攻击，安全性更强。 
>
> - GPAKE Gateway-oriented password-based authenticated key exchange
>
> **老师批注**：基于RSA的PAKE

### 总结归纳应用



### 研究内容与解决问题





### 研究方法



### 文章脉络

#### 1 引言

##### PAKE的相关研究

PAKE协议允许用户通过低熵的口令安全地建立一个共享的会话密钥，实现在不安全的公开的网络上的安全通信。口令低熵，故易受字典攻击

- EKE中提出基于RSA实现的协议容易受到`e次剩余攻击`，基于RSA的口令协议的研究不够完善和成熟
- OKE不能抵抗e次剩余攻击的一种变型
- SNAPI协议要求RSA的加密指数是一个比模数还大的素数，不够实用
- PEKEP和CEKEP协议允许用户选取一般的素数作为加密指数，但为了抵抗e次剩余攻击，需要服务器进行多次RSA加密，效率不高
- RSA-EPAKE不能抵抗一种分离攻击

##### 网关口令认证密钥交换协议

实际应用中，服务器由两个独立的实体组成：

- 一个是前端与用户直接交互的网关
- 另一个是后端验证用户身份的服务器

**用户和网关在服务器的协助下建立一个认证的会话密钥**，服务器和用户之间共享一个用于认证的口令，会话密钥是在网关和用户之间建立的

用户加密的消息发送给网关，网关直接将消息转发给服务器，服务器判断用户是否合法

**除了会话密钥的语义安全性，考虑另外两个安全目标：**（三个安全目标）

- 针对服务器的密钥私密性
	- 要求一个诚实而好奇的服务器在知道所有用户口令的条件下依旧不能将会话密钥和一个随机数区分开
- 针对网关的口令保护
	- 网关通过执行协议不能获得用户口令的任何信息

##### 本文工作

基于RSA体制设计高效的GPAKE协议，基于PEKEP协议来做

- 服务器和用户共享一个口令，用户和网关分别选取自己的RSA参数（模数和公私钥），无需在线证书验证
- 可以抵抗e次剩余攻击，基于RSA假设在随机预言模型下可证明安全

为了实现三个安全目标：

- 认证和会话密钥采用不同随机数，用户和服务器的认证不会泄露口令信息给网关，服务器也得不到用户和网关之间建立会话密钥的任何信息
- 采用RSA门限体制实现门限的GPAKE协议
- 协议无需任何参数，用户和服务器只需要共享一个口令，不需要建立其他的公共参数

在参与者没有足够资源产生或验证公共参数的一些性质时，这些协议很有吸引力

#### 2 安全模型

##### 概述

一般假设用户和网关之间的通信信道是不安全的并且由敌手控制，网关和服务器之间的通信存在安全通道，GPAKE协议的主要安全目标是为用户和网关建立一个安全的会话密钥，且不泄露用户口令的任何信息给网关。三个安全目标描述用户、服务器和网关的不诚实行为：

- 会话密钥的语义安全性，通过**“Real-Or-Random(ROR)”**攻击游戏来模型化
- 密钥私密性，要求在服务器协助下为用户和网关建立的会话密钥对服务器来说仍然是不可区分的
- 口令保护，指网关不能从服务器那里得到用户口令的任何信息

###### **协议的参与者**

$C$ 用户 $G$网关  $S$ 服务器  集合$U=C∪G∪S$

###### **长期密钥**

用户$C$持有口令$pw_c$，服务器持有口令列表$pw_s=<pw_c>_{c∈C}$ 每个用户口令都是列表中的一条记录，这两者称为用户和服务器的长期密钥

##### 安全模型

敌手的攻击能力通过预言询问模型化，协议执行过程中，敌手可以产生同一个参与者的多个并发运行的实例，$U^i$表示用户U的第i个实例，敌手可以进行的预言询问：

- $Execute(C^i,G^j)$ 模型化被动攻击，敌手被动窃听用户和网关之间的协议运行，**回答**是一次协议的诚实执行过程中用户和网关之间交换的所有消息

- $Send(U^i,m)$ 模型化对用户或网关实例$U^i$的主动攻击，敌手截获一条消息，对消息做篡改、产生新的消息或只转发，**回答**是参与者实例$U^i$接受到消息m的返回消息

- > ROR模型中，敌手可进行$Test$询问，*$b$是攻击游戏进行前随机选择的一个比特*

- $Test(U^i)$，不模型化敌手实际的攻击能力，是为了度量实例$U^i$所持有的会话密钥的语义安全性

	- 如果实例$U^i$的会话密钥没有定义，则返回一个未定义的标记⊥
	- 若已经生成，$b=1$时返回敌手真实的会话密钥；$b=0$时返回给敌手一个与密钥等长的随机比特串

- 在ROR模型中，**$Test$询问用于刻画敌手区分会话密钥和随机值的能力**，敌手可以对多个实例进行进行$Test$询问，所有$Test$询问的回答由随机选择的比特$b$决定，即所有$Test$询问的回答要么是真实的会话密钥，要么是随机选择的比特串
	- 在返回随机值的情况下，弱敌手对同一个会话中的两个实例进行$Test$查询，返回的随机值也相同
	- ✨ 敌手在ROR模型下的目标是**猜测$Test$询问中使用的随机比特b的值**，如果*敌手猜测正确，则敌手攻击成功*。

##### 安全定义

- **匹配会话** 

	- 通过会话标识和伙伴标识定义匹配会话，定义会话标识为协议执行结束后所有消息的级联，若两个实例拥有相同的非空会话标识称为**匹配会话** 比如$C^i$和$G^j$
		- $C^i$和$G^j$都接受
		- $C^i$和$G^j$拥有相同的会话标识
		- $C^i$的伙伴标识是$G^j$，反之亦然
		- 除了$C^i$和$G^j$外，没有接受的实例的伙伴标识为$C^i$或$G^j$

- **新鲜性**

	- 刻画一个敌手不能平凡获得的会话密钥，敌手只能对新鲜会话密钥进行$Test$询问，在协议执行中，实例如果被接受，则实例是新鲜的

- **会话密钥的语义安全性**

	- 敌手A可以进行所有预言询问，它的目标是猜测$Test$询问中所使用的随机比特$b$的值，$Succ$表示敌手A正确猜测$b$这一事件

	- ROR模型下，**敌手破坏认证密钥交换协议P的会话密钥的语义安全性的优势定义**为$Adv_{P,D}^{ake-ror}(A)=2×Pr[Succ]-1$

		- 对应的，协议$P$的优势函数为$Adv_{P,D}^{ake-ror}(t,R)=max\{Adv_{P,D}^{ake-ror}(A)\}$​，最大值从所有运行时间复杂度为$t$，使用资源为$R$如预言询问次数的敌手优势选取

		- > 优势函数表示在状态s下，某动作a相对于平均而言的优势，从数量关系看，是随机变量相对于均值的偏差

	- 一个GPAKE协议$P$称为语义安全的，如果：

		- 在任意的概率多项式敌手A的优势为$Adv_{P,D}^{ake-ror}(A)$只比$kn/|D|$大一个可以忽略的量，$n$是敌手A主动攻击的次数，$|D|$是口令空间的规模，$k$是一个常数
			- 一般$k=1$是最好的结果，敌手可以通过简单的在线字典攻击每次排除一个口令 ❓

- **密钥私密性**
	- [5] 指两个参与者在服务器的协助下生成的会话密钥只有两个参与者知道，服务器不知道该会话密钥的任何信息（半可信，为了降低对服务器的信任）
	- 如果一个获得服务器中储存的所有秘密信息的敌手A，仍然不能区分真实的会话密钥和随机数，则满足 **密钥私密性**
		- [5]中定义一种新的预言询问$TestPair$刻画密钥私密性，$TestPair$的输入为两个参与者的实例，输出为两个参与者实例共享的会话密钥或一个随机值
			- 攻击者可以进行$Execute$和$TestPair$询问，类似可以定义敌手破坏密钥私密性的优势$Adv_{P,D}^{ake-kp}(A)=2×Pr[Succ]-1$和协议P的优势函数$Adv_{P,D}^{ake-ror}(t,R)$
- **口令保护** 
	- 网关不能得到服务器存储的用户口令的任何信息
	- 如果恶意网关与服务器进行$q$次交互，要求恶意网关区分口令和随机值的概率至多为$kn/|D|$，其中$k=1$是最好的，恶意网关通过简单的在线字典攻击每次可以排除一个口令，但此时恶意网关仍然可以反复对用户的口令进行在线字典攻击，而服务器无法察觉。
		- 恶意网关A猜测用户口令，与服务器执行协议验证猜测是否正确，猜测过程服务器不能检测，则敌手成功
		- GPAKE协议P能够抵抗不可检测在线字典攻击，如果$Adv_{P,D}^{ake-unda}(A)$表示敌手成功概率，则GPAKE协议P能抵抗不可检测在线字典攻击的条件为：
			- $Adv_{P,D}^{ake-unda}(A)$只比$kn/|D|$大一个可以忽略的量

#### 基于RSA的GPAKE协议

##### 3.1 协议描述



基于RSA的口令认证密钥交换协议中，需要考虑协议是否能抵抗e次剩余攻击，采用了[12]的方法

- 要求服务器使用用户的公钥$(n,e)$进行$m+1$次RSA加密，其中$m=└log_e^n┘$
	- 计算效率，服务器需要进行$m+1$次RSA加密，计算负担较大
		- **但用户自行生成了公钥，因此知道$φ(n)$，对$z$解密得到$a$，实际只需要两次RSA解密**❓
		- 另外生成会话密钥还需要一次RSA加密和解密，用户共需要进行一次RSA加密和三次RSA解密，网关要执行一次RSA加密和解密
		- 在用户端和网管段的计算效率比较高，更适用于无线环境
	- 通信效率
		- 用户和网关需要进行四轮交互，目前基于RSA口令协议能达到的最少轮数

##### 3.2 安全性分析

利用安全模型证明协议的安全性，主要用到了RSA困难性假设

###### RSA假设



### 小标题

- 1 引言
	- 1.1 口令认证密钥交换协议
	- 1.2 相关工作
	- 1.3 我们的工作
- 2 安全模型
	- 2.1 概述
	- 2.2 安全模型
	- 2.3 安全定义
- 3 基于RSA的GPAKE协议
	- 3.1 协议描述
	- 3.2 安全性分析
- 4 总结