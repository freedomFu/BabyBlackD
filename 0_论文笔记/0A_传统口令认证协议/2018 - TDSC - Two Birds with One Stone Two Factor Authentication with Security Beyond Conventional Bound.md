> 2018 - TDSC - Two Birds with One Stone : Two-Factor Authentication with Security Beyond Conventional Bound 	一石二鸟，超越传统安全边界的双因素鉴别
>
> - **摘要：**在过去20年中，双因素鉴别方案中的基于智能卡的口令鉴别是研究人员的研究重点。但是当前还没有综合且系统的客观评估的方案，研究人员总是提出一些声称比之前更好的方案，却没有提及自己方案的弱点。因此，这些方案都不够好，要么缺少比较重要的安全目标要么缺少必需的属性，特别是无法满足安全性和可用性的权衡。为了克服这些问题，本文工作首先定义了一个安全模型，可以正确体现敌手的攻击能力，并提出了做比较评价的12个属性，让这些方案在一个范围内可以进行比较。另外一个主要的贡献是提出了一种新的方案解决用户损坏和服务器故障，而且在最严苛的敌手模型中实现了可证明安全性。在集成 *honeywords*之后，在系统安全范围内使用`fuzzy-verifier`，方案解决了两个问题：①消除了长期存在的安全性和可用性矛盾的问题；②实现了超过常规最佳安全边界的安全方案。
> - **关键词：** 
>   - Two-factor authentication 双因素鉴别
>   - smart card loss attack 智能卡丢失攻击
>   - Zipf’s law  Zipf定律
>   - provable security 可证明安全性
>   - random oracle model 随机预言模型
> - **优点：**
> 	- 提出自己的方案和研究目标的同时，严谨地论述了为什么前人的研究存在问题以及他们存在问题的原因

## 1 Introduction

在大量进行用户访问控制的方法中，基于口令的鉴别是最广泛使用的。一些著名的鉴别方案包括SRP、KOY和J-PAKE，用户持有一个可记忆的、低熵的口令，而服务器需要储存一个口令相关的验证表来鉴别用户。

口令鉴别机制固有的问题是，服务器必须要存储一个验证表。一旦鉴别服务器被攻破，则绝大多数的用户口令（可能是加盐哈希值）都可能被暴露出来：

- 人类的记忆是有限的，而用户选择的口令的分布又是高度倾斜的，即口令大多有相似的特征，而且一个人可能会选择同一个口令来访问多个服务器
- 口令破解硬件和算法的不断提高

更复杂的哈希函数从一定程度上缓解了这些问题，但是维护这样一个服务器也需要付出更高的代价。

门限方法实现的鉴别方法在一定程度上解决了服务器被破坏导致用户口令的泄露，但是它无法解决*用户端*口令泄露的问题，比如隐藏照相机、键盘记录和钓鱼攻击等。

`leakage-resilient password system(LRPS)` 提出，用户需要间接输入口令，这增加了用户的负担。后续研究表明，LRPS方案需要部署特定的可信设备来解决用户端的口令泄露问题，来达到合理的安全性和可接受的可用性。

以上两种方案的局限性引出了第三种解决方案，基于智能卡的口令，也即是双因素鉴别（大概30年前提出，1980s），这也是多因素鉴别机制的基础。

客户端$U$和鉴别服务器$S$，$U$首先提交自己选择的凭据（如身份信息和口令）给$S$，$S$会提交给$U$一个带有一些安全参数的智能卡，之后$U$可以和$S$可以互相鉴别。（本文没有讨论利用短消息设备作为第二个鉴别因素的协议。）

基于智能卡的口令鉴别方案最重要的安全目标是**实现真正的双因素安全**，即只有同时持有智能卡和相应口令的用户才能登录服务器。即满足：

- 能够拿到用户智能卡的攻击者不能通过离线字典攻击恢复用户的口令或模仿用户
- 获取用户口令但没获得智能卡的用户，不能模仿这个用户

除此之外，也应该支持一些抵抗其他被动或主动攻击，以及其他一些重要的属性，如本地口令更改、会话密钥协商和用户匿名性

历史上有许多针对双因素鉴别的研究，但是大多数研究只是声称比其他的研究更好，但是却忽视了自己方案的弱点，因此 *fair comparison and general consensus are unlikely*，也就是没有一个评判方案安全性的标准，

### 研究动机

> while little attention has been paid to the systematic design and evaluation of this sort of schemes and as a result, there is no common basis that allows schemes to be assessed thoroughly and fairly.
>
> - 没有一个对这类方案的系统的设计和评估，对于它彻底而公平地评估也没有什么基础

实现真正的双因素安全的难题是（这两个问题是难以解决的）

- 真正的双因素安全，即使智能卡丢失了
- 本地且安全的口令更新

另外，先前的研究都假设，用户选择的口令一般都是均匀地从口令空间$D$中得到的。这一点与实际情况是不一致的，在本文中作者也进行了分析。即对于口令的攻击，最优的情况就是敌手只能通过主动的在线猜测来进行口令字典攻击，而离线猜测、重放和并行会话攻击没有任何帮助。但是对于口令分布的误解导致真实的安全风险被低估了

### 本文贡献

- 提出了一种评估双因素鉴别方案的系统架构，还提出了一个实际的敌手模型和标准，可以更好地评估当前和未来的方案。
- 提出了对`honeywords`的防御战术，从系统安全层面深入了密码协议设计，提出了一种方案，可以即使检测用户电子卡的缺陷。
- 本文提出的方案可以满足评估框架中的12个属性，并可以在ROM模型下进行形式化安全性证明，而且该方案可以应用于许多其他的场景。

## 2. 攻击者模型和评估标准

在传统的口令认证密钥交换*PAKE*协议中，攻击者Ã被认为可以完全掌控公共通信通道，例如窃听、拦截、插入、删除和修改信息。为了描述前向安全性，敌手也可以攻破合法实体来获取长期私钥，而且之前的会话密钥也可能被Ã获取到。

后续研究表明，智能卡中的 *secret parameters*可能被（部分）提取，比如漏洞挖掘技术或逆向工程技术。泄露的参数可能使方案遭受 *smart card loss problem*，比如说离线口令猜测攻击和仿冒攻击。因此在假设智能卡设备中存储的 *secret key*可能被敌手获取到的情况下（比如恶意的读卡器）进行协议的设计是更加谨慎的。

在本文中，作者对敌手的能力做了约束：攻击者可以通过恶意读卡器首次拦截到口令并通过侧信道攻击读取卡中的信息。*the extreme-adversary principle*：敌手可以随意破坏任何类型的方案，而鲁棒性的方案可以抵御这样的攻击者。实际上这样的方案是合理的：

- 此场景中的用户可能将卡片插入恶意终端，但敌手可以实施侧信道攻击的可能性很小。
- 攻击者在一个较短的时间内获取敏感数据也是比较难的。

以上的分析可以说明，**除非智能卡长期被敌手获取，否则智能卡方案是防更改的**。（本文提出的一种假设）

作者的分析其实说明了这两种说法都是有问题的 *将智能卡设备理解为内存卡来进行需要的操作*或 *不考虑智能卡能提供的特殊安全特征*。在不可信的终端中使用基于存储卡的方案是不安全的。而上述两个假设实际是更加合理的。

为了用户友好型，一般允许用户自行选择ID，所以一般为低熵，可能被攻击者在多项式时间中被离线枚举。Ã可以离线枚举所有的$D_{id}×D_{pw}$中的所有$(ID,PW)$对。一些方案提出了用户匿名性，即假设敌手无法同时正确猜测$ID$和$PW$，这一点在本文方案中是不可能的。

### 敌手的能力：

- **C-01** 敌手可以离线枚举笛卡尔乘积$D_{id}×D_{pw}$
- **C-02** 敌手可以确定实体$U_i$的实体$ID_i$
- **C-1** 敌手可以控制整个通信通道
- **C-2** 敌手可以通过恶意读卡器获取实体的口令或通过侧信道攻击获取卡中的secret信息，但是不能同时完成两种攻击
- **C-3** 敌手可以获取之前的会话密钥
- **C-4** 当服务器被破坏时，敌手可以获取$S$的长期私钥以及其他存储在$S$中的数据

2012年的文献提出了三种安全模型，其中$Type-Ⅲ$是定义最强的，主要做了三个假设：

1. 敌手可以完全控制通信通道，与 *C-1*对应
2. 智能卡是防篡改的，用户口令可能被敌手通过恶意读卡器获取，但这两者可能不能同时满足，与 *C-2*对应
3. 敌手可以通过对无计数保护的卡发送一系列请求来获取有用的信息

对于第三点，本文认为可能没有实际意义，因为在假设2的前提下，第三点实际上与安全性没有什么关系：① 如果在智能卡没有起作用之前，输入口令没有验证，则敌手可以获取有用信息（除了卡中的静态数据）的唯一方式是与远程服务器交互，而这可以被服务器发现，比如通过限制次数来屏蔽。② 另一方面，如果输入口令过程有验证，敌手可以通过输入口令到恶意读卡器来找到口令，而且此时 *secret data*也可能被读取出来。但其实这两点在上述假设中都是不允许的，所以该条在本模型中是不允许的，在本文中假设 *card*是有计数保护的，即如果尝试次数超过了一个门限值就会被锁住。但该假设没有实现前向安全性以及抵抗已知密钥攻击

当用户匿名性被考虑时，则可以去除 *C-02*

> Particularly, the practicality of our model is confirmed by the fact that, under such a strong model, secure and efficient protocols can still be built 

### 评估标准

作者根据用户友好性和安全性定义了双因素鉴别方案应该满足的12个独立的标准：

- *C1 No password verifier-table* 服务器不需要维护一个存储用户口令或从用户口令中读取的值
- *C2 Password friendly*  口令是用户可以随意选择的
- *C3 No password exposure* 口令不能被服务器的管理员提取 
- *C4 No smart card loss attack* 未授权的用户即使拿到了智能卡也不能轻易通过猜测攻击修改口令或冒充用户登录系统，即使智能卡被获取并且其中的 *secret data*被获取 。
	- 此时敌手已经获取了用户的智能卡
- *C5 Resistance to known attacks* 可以抵抗离线口令猜测攻击、重放攻击、并行会话攻击、去同步化攻击、盗窃`verifier`攻击、模仿攻击、密钥控制、未知密钥共享攻击和已知密钥攻击 
	- 此时敌手没有获取用户智能卡
- *C6 Sound repairability* 用户可以在不更改实体的情况下撤销 card 
- *C7 Provision of key agreement* 客户端和服务器可以在认证过程建立一个会话密钥 
- *C8 No clock synchronization*  不需要时钟同步
- *C9 Timely typo detection* 用户可以及时发现他在登录时输入了错误的口令 
- *C10 Mutual authentication*  可以完成双向鉴别
- *C11 User anonymity* 方案可以保护用户实体防止被跟踪 
- *C12 Forward secrecy*  方案提供完美前向安全性

后续评估的67个方案中，对于每一个规范，至少15个满足它，而至少有7个不满足，而且没有任何一个方案是满足每一条规范的。

## 形式化安全模型 Formal Security Model 

为了形式化分析在基于智能卡的口令鉴别环境中敌手的能力，作者重新用了2000年BPR安全模型，采用了2003年CCS提出的更具体化的版本，此时作者可以自己定义与双因素鉴别相关的关系。本文没有涉及用户匿名性。

**Players.**

**Long-Lived Keys.**

**Queries.**

![image](https://user-images.githubusercontent.com/40269368/158319171-2318cf6c-2d1a-4120-9791-419bc8c463c7.png)

![image](https://user-images.githubusercontent.com/40269368/158325100-368aa7b3-1783-4eab-bd89-6f0909135dd6.png)

在一个安全的只有口令的协议中，敌手可以执行的最佳策略是在线口令猜测攻击（而且是在每个猜测会话中只能猜测一个口令候选值），这很容易被检测到且容易被击败。

对于无篡改抵抗假设的基于智能卡的双因素鉴别方案来说，在线口令猜测攻击也应该是敌手的最好能力：

1. 如果口令被破坏而智能卡没事，由于智能卡中存储着高熵的私密数据所以很难成功。
2. 如果智能卡被破坏而口令没事，则敌手至少可以尝试与服务器通信来猜测口令。通过Execute查询的不属于在线攻击。

有以下定义，双因素协议P可以实现双向鉴别，如果在任何概率多项式时间(PPT)中，敌手最多可以做$q_{send}$次在线攻击，满足：$Adv_{P,D}^{auth}(A)≤C'·q_{send}^{s'}+ε(ι)$

其中，$D$是口令空间，$C'$和$s'$是`Zipf`的参数，$ι$是系统安全参数。结果需要敌手的被动攻击对它是没用的。作者论证了 *our Zipf-modelled formulation is particularly suitable for capturing Attacker’s online guessing advantage.*

![image](https://user-images.githubusercontent.com/40269368/158332571-bed2b05a-5157-45ec-863e-ed30d7a6fd4e.png)

双因素协议是语义安全的：如果任何概率多项式攻击者$Ã$最多可以做$q_{send}$次在线攻击，有：

$Adv_{P,D}^{auth}(A)≤C'·q_{send}^{s'}+ε(ι)$

## 提出的方案

提出的方案包含四个部分：注册、登录、验证和口令修改。包含如下的符号表示：

![image](https://user-images.githubusercontent.com/40269368/158333734-860072ff-3f21-4f7d-8f25-de0d88932e9a.png)

![image](https://user-images.githubusercontent.com/40269368/158342684-c2c542dc-4747-4776-9b2b-8b0015bcab9a.png)

![image](https://user-images.githubusercontent.com/40269368/158489253-b7f5b975-5858-4667-adfb-f355e8de043e.png)

![image](https://user-images.githubusercontent.com/40269368/158489281-64424336-cc3d-4733-ab54-b446c6acf595.png)

![image](https://user-images.githubusercontent.com/40269368/158489314-80a54fae-055a-4da7-b4ae-c6b03a3d20da.png)

## 协议设计逻辑依据

在本节中介绍了协议的设计思想， *honeywords* 与 *fuzzy-verifier*的集成，不仅解决了长期的安全性和可用性的矛盾，而且实现了超出传统最优边界的安全性。

### 基本思想



### *Fuzzy-Verifier*的作用

作者在进行的实验时选择了空间$n_0=2^8$，因为最流行的口令都处于这个区间，其中包含：

- 敌手$Ã$很关心性能，因此可能不会去尝试那些很少见的口令
- 如果流行口令的部分都可以确保猜测熵GE，那么低流行的那个部分则可以达到那个目标

当数据集小于300万时，每一个口令库都可以达到$GE≥2^{12}$，表明，即使$A_i$被提取出来了，仍然存在$2^{12}$个口令候选值需要敌手在线猜测。所以 *fuzzy-verifier*是非常有效的

![image](https://user-images.githubusercontent.com/40269368/158510091-5cd92481-3425-4c33-96aa-a1653bfe556d.png)

### *Fuzzy-Verifier+Honeywords*的作用



### 本文方案的应用场景



## 形式化安全分析





## 性能评估













